name: Validate lexicon

on:
  pull_request_target:
    paths:
      - "lexicons/**"
      - ".github/workflows/ci.yml"

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  check:
    runs-on: ubuntu-latest
    outputs:
      finished: ${{ steps.lint.outcome == 'success' || steps.lint.outcome == 'failure' || steps.breaking.outcome == 'success' || steps.breaking.outcome == 'failure' || steps.breaking.outcome == 'success' || steps.breaking.outcome == 'failure' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Install goat
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release download --repo bluesky-social/goat --pattern 'goat_Linux_x86_64.tar.gz' --output 'goat.tar.gz'
          tar -xzf goat.tar.gz --directory /usr/local/bin
          chmod +x /usr/local/bin/goat

      - name: Print goat version
        continue-on-error: false
        run: goat -v

      - run: mkdir -p logs

      # We capture stderr here too, so we can detect if linting failed:
      - name: Lint lexicon files
        id: lint
        run: |
          goat lex lint --json | jq --slurp | tee logs/lint.json

      - name: Check for lint errors
        id: lint-errors
        continue-on-error: true
        run: |
          hasErrors=$(jq 'any(."lint-level" | contains("error"))' logs/lint.json)
          if [ "$hasErrors" = "true" ]; then
            exit 1
          fi

      # We capture stderr here too, as warnings can be issues:
      - name: Check lexicon files for breaking changes
        id: breaking
        continue-on-error: true
        run: |
          set -eo pipefail
          goat lex breaking 2>&1 | tee logs/breaking-changes.txt

      - name: Check for dns records for lexicon
        id: dns
        continue-on-error: true
        env:
          DID: ${{ vars.DID }}
        run: |
          set -eo pipefail
          goat lex check-dns --did $DID | tee logs/check-dns.txt

      - name: Upload check results
        if: success() || failure()
        uses: actions/upload-artifact@v6
        with:
          name: check-logs
          path: logs

      - name: Report on failures
        if: steps.lint-errors.outcome != 'success' || steps.breaking.outcome != 'success' || steps.dns.outcome != 'success'
        run: exit 1

  updateComment:
    runs-on: ubuntu-latest
    needs: check
    if: success() || failure()
    permissions:
      pull-requests: write
    steps:
      - uses: actions/setup-node@v4
        with:
          node-version: "24.x"
      - uses: actions/download-artifact@v7
        with:
          name: check-logs
          path: logs

      - run: ls -lR logs

      - name: Prepare comment
        uses: actions/github-script@v8
        id: comment
        env:
          VALIDATED: ${{ needs.check.outputs.finished }}
        with:
          script: |
            const fs = require('node:fs/promises')

            const validated = process.env.VALIDATED === 'true'
            if (!validated) {
              await fs.writeFile('comment.txt', "## ‚ÄºÔ∏è Error: Workflow failed to run completely", { encoding: 'utf8' })
              return;
            }

            let output = []

            const lint = await fs.readFile('logs/lint.json', { encoding: "utf8" }).then((text) => JSON.parse(text)).catch((err) => { return [] })
            const changes = await fs.readFile('logs/breaking-changes.txt', { encoding: "utf8" }).catch((err) => { return false })
            const dns = await fs.readFile('logs/check-dns.txt', { encoding: "utf8" }).catch((err) => { return false })

            if (lint.length) {
              const errors = lint.filter((check) => check["lint-level"] === 'error')
              const warnings = lint.filter((check) => check["lint-level"] === 'warn')

              if (errors.length) {
                output.push("## ‚ÄºÔ∏è Linting Errors")
              } else if (warnings.length) {
                output.push("## üü° Linting Warnings")
              } else {
                output.push("## ‚úÖ Linting")
              }

              if (errors.length || warnings.length) {
                const lintOutput = []
                
                if (errors.length) {
                  lintOutput.push('**Errors:**')
                  errors.each((check) => {
                    lintOutput.push(`* \`${check.nsid}\`: ${check['lint-description']} in \`${check['file-path']}\``)
                  })
                }

                if (warnings.length) {
                  lintOutput.push('**Warnings:**')
                  warnings.each((check) => {
                    lintOutput.push(`* \`${check.nsid}\`: ${check['lint-description']} in \`${check['file-path']}\``)
                  })
                }

                output.push(lintOutput.join('\n'))
              } else {
                output.push('No linting issues found.')
              }
            }

            if (changes) {
              if(changes.includes('error')) {
                output.push("## ‚ÄºÔ∏è Incompatible Changes")
                output.push(`<pre>${changes}</pre>`)
              } else {
                output.push("## üü° Incompatible Changes")
                output.push(`<details><summary>Received non-error output:</summary><pre>${changes}</pre></details>`)
              }
            } else {
              output.push("## ‚úÖ Incompatible Changes")
              output.push("No breaking changes were detected.")
            }

            if (dns && !dns.includes("successfully")) {
              output.push("## ‚ÄºÔ∏è DNS Issues")
              output.push(`<pre>${dns}</pre>`)
            }

            await fs.writeFile('comment.txt', output.join("\n\n"), { encoding: 'utf8' })

      - name: Print comment
        run: cat comment.txt
      - name: Add comment to pull request with results
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
          PULL_REQUEST: ${{ github.event.pull_request.number }}
        run: |
          gh pr comment $PULL_REQUEST --create-if-none --edit-last --body-file comment.txt --repo $REPO
